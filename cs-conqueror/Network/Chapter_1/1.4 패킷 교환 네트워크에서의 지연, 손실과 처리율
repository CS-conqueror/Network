# 1.4 패킷 교환 네트워크에서의 지연, 손실과 처리율

> 인터넷은 종단 시스템에서 수행되는 **분산 애플리케이션에게 서비스를 제공하는 인프라스트럭처**이다. (1.1절)

이상적으로는 인터넷 서비스가 데이터의 손실 없이 즉시 두 종단 시스템 간에 원하는 만큼의 데이터를 이동시키기를 원한다.

하지만 현실에서 이는 어려우며, 컴퓨터 네트워크는 두 종단 시스템 간에 전달될 수 있는 초당 데이터의 양, 즉 **처리율을 제한한다.**

**이로 인해 종단 시스템 간에 지연이 발생하며, 패킷을 잃어버리게 되기도 한다.**

<br/>
<br/>
<br/>

# 1.4.1 패킷 교환 네트워크에서의 지연 개요

패킷은 한 호스트(출발지)에서 시작하고 일련의 라우터들을 통과하며 다른 호스트(목적지)에 도달한다.

패킷이 경로를 따라 한 노드에서 다음 노드로 전달될 때 패킷은 경로상의 **각 노드에서** 다양한 지연을 겪게 되며,  
이들은 쌓여서 `전체 노드 지연(total nodal delay)`을 일으킨다.

- `노드 처리 지연(nodal processing delay)`
- `큐잉 지연(queuing delay)`
- `전송 지연(transmission delay)`
- `전파 지연(propagation delay)`

<br/>

아래의 그림을 보며 큰 그림을 그려보자. 이는 라우터 A에서의 노드 지연을 나타낸 것이다.

<p align="center"><img width="470" alt="노드 지연" src="https://user-images.githubusercontent.com/86337233/210216460-d4e1eacc-cde9-4185-aca8-661e78a20427.png">

<br/>
<br/>


출발지와 목적지 사이 종단 간 경로의 일부로서, 한 패킷이 업스트림 노드로부터 라우터 A를 통해 라우터 B로 보내진다.

- `업스트림(upstream)` : 클라이언트에서 서버로 전송되는 데이터의 흐름
- `다운스트림(downstream)` : 서버에서 클라이언트로 전송되는 데이터의 흐름, 일반적으로 다운스트림 트래픽은 업스트림 트래픽보다 더 많은 볼륨이 있다.

<br/>

라우터 A는 라우터 B에 이르는 `하나의 출력(outgoing) 링크`를 가지며, 이 링크 앞에 `큐(queue, 버퍼(buffer))`가 존재한다.

1. 패킷이 업스트림 노드로부터 라우터 A에 도착한다.
2. 라우터 A는 그 패킷에 대한 적당한 출력 링크를 결정하기 위해 패킷 헤더를 조사한다.
3. 라우터 A는 선택된 링크로 그 패킷을 보낸다. (그림에서 선택된 링크 = 라우터 B에 이르는 링크)

<br/>

```
만약 라우터 B에 이르는 링크에 현재 전송되는 다른 패킷이 존재하거나, 큐에 자신보다 앞선 다른 패킷들이 존재한다면 어떻게 되는가?
```

새로 도착하는 패킷은 그 링크를 이용하기 위해 큐에 들어갈 것이다.

<br/>

_이 모든 과정에서 여러 지연이 발생한다._

<br/>

### 처리 지연(processing delay)

> 💡 패킷 헤더를 조사하고 그 패킷을 어디로 보낼지 결정하는 시간

- 라우터 A로 패킷의 비트를 전송할 때 업스트림 노드에서 발생하는 **패킷의 비트 레벨 오류를 조사**하는 데 필요한 시간과 같은 요소를 포함할 수도 있다.
- 라우터는 이 노드 처리 후, 그 패킷을 라우터 B에 이르는 링크에 앞선 큐에 보낸다.
- 고속 라우터의 처리 지연은 일반적으로 수 마이크로초이다.

<br/>

### 큐잉 지연(queuing delay)

> 💡 패킷이 큐에서 링크로 전송되기를 기다리는 시간

- 특정 패킷의 큐잉 지연 길이는 큐에 저장되어 링크로 전송되기를 기다리는, **앞서 도착한 다른 패킷의 수에 의해 결정된다.**
- 주어진 패킷의 지연은 패킷마다 상당히 다르다.
    - 큐가 비어있고 다른 패킷이 전송 중인 상태가 아니라면 패킷의 큐잉 지연 → 0
    - 트래픽이 많고 다른 많은 패킷이 전송 대기 중이라면 패킷의 큐잉 지연 → 매우 길어진다.
- 수 마이크로초 ~ 수 밀리초

<br/>

### 전송 지연(transmission delay)

> 💡 패킷의 모든 비트를 링크로 밀어내는 데(또는 전송하는 데) 필요한 시간


패킷이 **선입선출(FIFO)** 방식으로 전송된다고 가정해보자. (앞서 도착한 다른 모든 패킷이 전송된 다음에 전송)

패킷의 길이는 `L 비트`, 라우터 A에서 라우터 B까지 링크의 전송률은 `R bps`라고 해보자. (R는 라우터 B로 가는 링크의 전송률에 의해 결정됨)

이때 전송 지연은 `L/R`이다. (수 마이크로초 ~ 수 밀리초)

<br/>

### 전파 지연(propagation delay)

> 💡 비트가 라우터 A 상에서의 링크에서 라우터 B까지의 전파에 필요한 시간

- 비트는 링크의 전파 속도로 전파된다.
- 전파 속도는 링크의 물리 매체(광섬유, 꼬임쌍선 등)에 따라 다르며, 범위는 2×(10^8)미터/초 ~ 3×(10^8)미터/초이다.  
  → 빛의 속도와 같거나 약간 작다.

라우터 A와 B 사이의 거리를 `d`, 링크의 전파 속도를 `s`라고 한다면 전파 지연은 `d/s`이다. (일반적으로 수 밀리초)

<br/>

### 전송 지연(transmission delay)과 전파 지연(propagation delay)의 비교

#### 전송 지연

- **라우터가 패킷을 내보내는 데** 필요한 시간
- 패킷 길이와 링크 전송률의 함수 → 두 라우터 사이의 거리와는 관계가 없다.

#### 전파 지연

- 비트가 **한 라우터에서 다음 라우터로 전파되는 데** 걸리는 시간
- 두 라우터 사이의 거리에 대한 함수 → 패킷 길이나 링크 전송률과는 관계가 없다.

<br/>
<br/>

## 전체 노드 지연(total nodal delay)

> 💡 전체 노드 지연 = 처리 지연 + 큐잉 지연 + 전송 지연 + 전파 지연

<br/>

각각 지연 요소의 기여도에는 상당한 차이가 존재한다.

#### 전파 지연(propagation delay)

- 내부의 두 라우터를 연결하는 링크에서는 2마이크로초 정도 → 무시 가능
- 정지 위성 링크로 연결된 두 라우터의 경우 수백 밀리초 → 전체 노드 지연의 주요 요소가 된다.

#### 전송 지연(transmission delay)

- LAN처럼 10 Mbps 이상의 전송률인 경우 → 무시 가능
- 저속 다이얼업 모뎀 링크에서 보내지는 인터넷 패킷은 수백 밀리초에 이를 수 있다.

#### 처리 지연(nodal processing delay)

- 이는 보통 전체 노드 지연에서는 무시될 수 있다.
- 하지만 라우터가 패킷을 전달할 수 있는 최대율(최대 속도)에는 상당한 영향을 준다.

<br/>
<br/>
<br/>

# 1.4.2 큐잉 지연과 패킷 손실

<b>노드 지연(한 라우터에서의 지연)</b>에 대하여 알아보자.

다른 세 가지 지연과 다르게, 큐잉 지연은 패킷마다 다를 수 있다.

<br/>

e.g., 10개의 패킷이 동시에 비어 있는 큐에 도착한다면?

- 전송된 첫 패킷은 큐잉 지연을 겪지 않는다.
- 마지막으로 전송되는 패킷은 많은 큐잉 지연을 겪게 된다. (다른 9개 패킷이 전송되기를 기다림)

따라서 큐잉 지연의 특성 묘사는 평균 큐잉 지연, 큐잉 지연의 분산, 큐잉 지연이 어느 특정 값을 넘을 확률 같은 **통계 측정을 일반적으로 이용한다.**

<br/>

### 큐잉 지연을 결정하는 주 요소들

- 트래픽이 큐에 도착하는 비율
- 링크의 전송률
- 도착하는 트래픽의 특성 (트래픽이 주기에 맞춰서 또는 버스트(burst)하게 도착하는가?)

<br/>

---

<br/>

아래의 상황을 가정해보자.

```
패킷이 큐에 도착하는 평균율 : a 패킷/초
전송률(패킷이 큐에서 밀려나는 비율) : R 비트/초
모든 패킷은 L 비트
큐가 매우 커서 무한대 비트를 저장할 수 있음
```

이때 `트래픽 강도`(traffic intensity, **비트가 큐에 도착하는 평균율**)은 `La/R` 비트/초다.  
(트래픽 강도는 큐잉 지연의 정도를 측정하는 데에 매우 중요)

<br/>

✅ `La/R > 1`이라면 **비트가 큐에 도착하는 평균율이 비트가 큐에서 전송되는 비율을 초과한다**는 것을 의미한다.

따라서 큐는 끝없이 증가, 큐잉 지연은 무한대에 도달한다. *→ 트래픽 강도가 1보다 크지 않게 시스템을 설계해야 한다.*

<br/>

✅ `La/R ≤ 1`인 경우에는 도착 트래픽의 특성이 큐잉 지연에 영향을 미친다.

- 하나의 패킷이 L/R 초마다 주기적으로 도착한다면 모든 패킷은 빈 큐에 도착 → 큐잉 지연은 없을 것이다.
- 패킷이 몰려서(burst) 도착한다면 상당한 **평균 큐잉 지연이 발생**할 것이다.

<br/>

---

<br/>

일반적으로 패킷의 도착에는 고정된 패턴이 없고, 임의의 시간만큼 떨어져서 도착하게 된다. (random)

아래 그래프는 **트래픽 강도에 대한 평균 큐잉 지연의 질적 의존도**를 나타낸다.

<p align="center"><img width="320" alt="평균 큐잉 지연의 트래픽 강도 의존성" src="https://user-images.githubusercontent.com/86337233/210216463-79992219-167f-4340-ab30-31383deac4d3.png">

<br/>
<br/>

> 💡 트래픽 강도가 1에 접근할수록 평균 큐잉 지연이 급속히 증가한다.

- 트래픽 강도가 0에 가까울 경우
    - 패킷 도착이 드물고 간격이 멀어서 다음에 도착하는 패킷이 큐에서 다른 패킷을 발견하는 경우가 없다.
    - 따라서 평균 큐잉 지연은 0에 가까워진다.


- 트래픽 강도가 1에 가까울 경우
    - 패킷 도착이 전송용량을 초과하여 큐가 생성될 것이다.
    - 도착률이 전송률보다 작아질 때 큐의 길이가 줄어든다.

<br/>

### 패킷 손실

앞에서는 큐가 무한대 패킷을 가질 수 있다고 가정했으나, 실제로는 **유한 용량**을 가지며 스위치 설계와 비용에 크게 의존한다.

즉, 트래픽 강도가 1에 접근함에 따라 패킷 지연이 무한대가 되진 않으며, 대신 큐가 꽉 차게 된다.

<br/>

> 💡 큐가 꽉 차서 패킷을 저장할 수 없는 경우에 라우터는 그 패킷을 **버린다(drop).**

- **손실 패킷의 비율은 트래픽 강도가 클수록 증가한다.**
- 모든 데이터가 궁극적으로 목적지까지 전달되었음을 보장하기 위해 손실 패킷은 종단 간에 **재전송**될 수 있다.

<br/>

---

<br/>

정리하자면, **노드에서의 성능 측정 요소**는 다음의 두 가지이다.

- 지연 정도
- 패킷 손실 확률

<br/>
<br/>
<br/>

# 1.4.3 종단 간 지연

**출발지에서 목적지까지의 지연**에 대하여 알아보기 위해, 다음의 상황을 생각해보자.

```
출발지 호스트와 목적지 호스트 사이에 N-1개의 라우터가 있다.
네트워크가 혼잡하지 않아 큐잉 지연을 무시할 수 있다.
각 호스트와 출발지 호스트에서의 전송률은 R 비트/초이다.
패킷의 크기는 L 비트이다.
```

> 종단 간 지연 = N(처리 지연 + 전송 지연(L/R) + 전파 지연)

<br/>

*이는 1.3절에서 언급한, 처리와 전파 지연을 고려하지 않은 종단 간 지연 식을 일반화한 것이다.*

<p align="center"><img width="250" alt="종단 간 지연" src="https://user-images.githubusercontent.com/86337233/210137330-0534c802-b6cd-41e4-915d-d8a3dac5d07a.png">

<br/>
<br/>
<br/>
<br/>

# 1.4.4 컴퓨터 네트워크에서의 처리율

컴퓨터 네트워크에서의 주요한 성능 수단은 다음의 세 가지이다.

- 지연 정도
- 패킷 손실 확률
- `종단 간 처리율(throughput)`

<br/>

컴퓨터 네트워크를 통해 호스트 A에서 호스트 B로 커다란 파일을 전송하는 상황을 생각해보자.

해당 파일은 **F 비트**로 구성되며, 호스트 B가 파일의 모든 F 비트를 수신하는 데 **T초**가 걸린다고 한다면,

- 어느 한 순간에서의 `순간적인 처리율(instantaneous throughput)` = 호스트 B가 파일을 수신하는 비율(비트/초)
- `평균 처리율(average throughtput)` = F/T 비트/초

<br/>

인터넷 전화 같은 애플리케이션의 경우, **낮은 지연과 순간적인 처리율이 지속적으로** 어떤 임계값(threshold)을 넘는 것이 바람직하다.

파일 전송을 포함하는 다른 애플리케이션의 경우, 지연은 심각하지 않으나 **가능한 한 높은 처리율**을 가지는 것이 바람직하다.

<br/>

---

<br/>

서버로부터 클라이언트로의 파일 전송에 대한 처리율을 생각해보기 위해 두 가지 예시를 보자.

<p align="center"><img width="500" alt="파일 전송 처리율" src="https://user-images.githubusercontent.com/86337233/210216470-eff94fd0-1b04-4efd-aa60-85f7bad15507.png">

<br/>
<br/>

```
그림 a는 2개의 통신 링크와 라우터로 연결된 하나의 서버와 하나의 클라이언트를 나타낸다.
(전체 네트워크로 보내지는 비트는 서버에서 클라이언트로만 보내지는 비트라고 가정)

Rs : 서버와 라우터 간의 링크 속도
Rc : 라우터와 클라이언트 간의 링크 속도
```

이때 **서버-클라이언트 처리율**은 얼마인가? *(비트는 유체(fluid), 통신 링크는 파이프(pipe)로 생각해보자)*

<br/>

서버는 Rs bps보다 빠른 속도로 링크상으로 비트를 내보낼 수 없고, 라우터는 Rc bps보다 빠른 속도로 비트를 전달할 수 없다.

- `Rs < Rc`인 경우 : Rs bps
- `Rc < Rs`인 경우 : Rc bps
    - 라우터는 자신이 수신하는 비트만큼 빠르게 그 비트들을 전달할 수 없다.
    - 클라이언트로의 전송을 위해 기다리는 라우터의 비트들은 계속해서 증가할 것이다.

> 처리율 = min{Rc, Rs} = 병목 링크(bottleneck link)의 전송률

<br/>
<br/>

```
그림 b는 서버와 클라이언트 간에 N개의 링크를 가진 네트워크를 보여주고 있다.
N개 링크의 전송률 : R1, R2, ... , RN
```

이때의 서버-클라이언트 처리율은 그림 a에서와 마찬가지이다.

> 처리율 = min{R1, R2, … , RN} = 서버와 클라이언트 간 경로상에서의 **병목 링크(bottleneck link)의 전송률**

<br/>

---

<br/>

아래는 오늘날의 인터넷에서 살펴볼 수 있는 다른 두 가지 예시이다.

<p align="center"><img width="400" alt="종단 간 처리율" src="https://user-images.githubusercontent.com/86337233/210216466-21232719-49ba-41e4-a6f9-af5491b6ffd2.png">

<br/>
<br/>

```
그림 a는 컴퓨터 네트워크로 연결된 2개의 종단 시스템을 나타낸다.
(전체 네트워크로 보내지는 비트는 서버에서 클라이언트로만 보내지는 비트라고 가정)

Rs : 서버가 네트워크에 연결되어 있는 접속 링크 속도
Rc : 클라이언트가 네트워크에 연결되어 있는 접속 링크 속도

통신 네트워크의 코어에 있는 모든 링크가 Rs와 Rc보다 매우 높은 전송률을 가지고 있다.
(실제로도 그렇다. → 오늘날 인터넷의 코어는 작은 혼잡을 경험)
```

이때도 마찬가지로, 출발지에서 목적지로 흐를 수 있는 비트 속도는 Rs와 Rc의 최솟값과 같다.

> 처리율 = min{Rc, Rs}

<br/>

> 💡 오늘날의 인터넷에서의 처리율에 대한 제한 요소는 전형적으로 접속 네트워크다.

<br/>
<br/>

```
그림 b는 컴퓨터 네트워크의 코어에 연결된 10개의 서버와 10개의 클라이언트를 나타내며,
10개의 동시적인 다운로드가 일어나고 있다. (10개의 클라이언트-서버 쌍)
(현 시각, 이러한 10개의 다운로드가 네트워크에서의 유일한 트래픽이라고 가정)

10개의 다운로드가 통과하는 코어에 하나의 링크 R가 존재한다.

R : 링크 R의 전송률
Rs : 모든 서버 접속 링크가 가지고 있는 속도
Rc : 모든 클라이언트 접속 링크가 가지고 있는 속도

코어에서의 모든 링크의 전송률(속도 R인 하나의 공통 링크는 예외)은 Rs, Rc, R보다 크다고 가정한다.
```

이때 **다운로드의 처리율**은 얼마인가?

공통 링크 R의 속도가 크다면 각 다운로드에 대한 처리율은 min{Rs, Rc}이 될 것이다.

<br/>

**하지만 공통 링크 R의 속도가 Rs, Rc와 같은 수준이라면 어떻게 되는가?**

e.g., Rs = 2 Mbps, Rc = 1 Mbps, R = 5 Mbps  
→ 공유 링크는 각 다운로드에 500 kbps의 처리율을 제공하기에, 각 다운로드에 대한 종단 간 처리율은 500 kbps로 줄어든다.

**즉, 코어에서의 공유 링크가 각 다운로드에 대한 병목이 된다.**

<br/>

---

<br/>

위의 예시들을 한 줄로 정리하자면 다음과 같다.

> 💡 처리율은 **데이터가 흐르는 링크의 전송률**에 의존할 뿐만 아니라 **간섭 트래픽**에도 의존한다.
