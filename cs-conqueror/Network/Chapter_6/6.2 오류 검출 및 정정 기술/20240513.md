# 6.2 오류 검출 및 정정 기술

<p align="center"><img width="400" alt="오류 검출" src="https://user-images.githubusercontent.com/76640167/214039458-a74c70d2-02cf-4826-aa1c-af15edab8b58.png">

비트 오류를 방지하기 위해 송신 노드에서 `데이터 D`에 `오류 검출 및 정정 비트들(EDC)`를 추가

<br/>

송신되는 `데이터 D`와 `EDC`는  전송 도중 변경 가능

수신자는 변경의 가능성이 있는 비트로 오류 검출 여부를 확인해야 함

<br/>

오류 검출 및 정정 기술을 사용하더라도 여전히 미검출된 비트 오류(undetected bit error)가 있을 수 있음

수신자는 잘못된 데이터그램을 네트워크 계층으로 전달할 수 있고, 프레임 헤더의 다른 필드의 내용이 잘못된 것을 모를 수도 있음

따라서 오류를 감지하지 못할 확률이 낮은 기법을 선택해야함 (대체로 확률이 낮을 수록 오버헤드가 큼)

<br/>


## 6.2.1 패리티 검사

### 단일 패리티 비트

<p align="center"><img width="250" alt="패리티 비트" src="https://user-images.githubusercontent.com/76640167/214039452-91447fa5-b3b5-42e3-bafd-10cce4bc00e4.png">

데이터 D가 d개의 비트를 갖고 있다고 가정

짝수 패리티 기법에서는 단순히 D에 한개의 `Parity bit`를 추가하고, d+1개의 비트에서 1의 총개수가 짝수가 되도록  `Parity bit` 을 선택 ( 0 or 1 )

수신자는 수신된 d+1개의 bit에서 1의 개수가 짝수임을 확인

(홀수 패리티 기법이라면 1의 개수를 홀수로 정함)

<br/>


이 방법의 경우 홀수개의 비트 오류는 검출할 수 있지만 짝수개의 비트 오류는 검출할 수 없음

측정에 의하면 오류는 종종 버스트(burst)의 형태로 몰려서 발생하기 때문에 위 방법은 50% 확률로 오류를 검출할 수 있음

<br/>

### 2차원 패리티

<p align="center"><img width="350" alt="2차원 패리티 비트" src="https://user-images.githubusercontent.com/76640167/214039449-ce67b6cd-f4ea-4042-b93b-bc57003f4e37.png">

데이터 D에 있는 d 비트들은 i개의 행과 j개의 열로 나뉨

나뉜 각각의 행과 열에 대해 하나의 패리티 값 계산

<br/>

2차원 패리티 기법에서는 반전된 비트를 포함하는 열과 행에 대한 패리티에 오류가 생김

따라서 수신자는 단일 비트의 **오류 발생을 검출할 수 뿐만 아니라 열과 행의 인덱스 값을 통해 오류를 정정**할 수 있음

단일 패리티와는 달리 임의의 2개의 오류도 검출할 수 있지만 정정할 수는 없음

<br/>

### 순방향 오류 정정(forward error correction, FEC)

오류를 검출 및 정정하는 수신자의 능력

`FEC` 기술은 송신자에게 요구하는 재전송 횟수를 줄일 수 있음

수신자가 즉각적인 오류 정정을 할 수 있음

이를 통해 NAK 패킷을 수신하고 재전송된 패킷이 수신자로 되돌아가는 소요 시간이 왕복 지연 시간을 기다릴 필요가 없어짐

(NAK이란? 받은 패킷에 오류가 있다거나 잘못된 순서로 받았다는 뜻으로, 문제가 있는 패킷의 번호와 함께 보내짐)

<br/>

## 6.2.2 체크섬 방법

d 비트들을 k 비트 정수처럼 다루어 이 k비트 정수들을 더해서 그 결괏값을 오류 검출 비트들로 사용

<br/>

### 체크섬 동작 과정

`인터넷 체크섬(Internet checksum)`

1. 더한 값의 1의 보수가 인터넷 체크섬이 되며, 이것을 세그먼트 헤더에 넣음
2. 수신자는 수신 데이터 합의 1의 보수를 취한 후 그 결과가 모두 1인 비트로 구성되어 있는지 계산함으로써 체크섬을 검사
3. 그 결과가 모두 1인 비트로 구성되어 있는지 계산함으로써 체크섬을 검사

<br/>

체크섬 방법은 상대적으로 패킷 오버헤드가 적어 `TCP`와 `UDP`에서 사용하지만 `순환 중복 검사(CRC)`와 비교하면 오류면에서 취약

`TCP`와 `UDP`에서 사용하는 이유는 `TCP`와 `UDP`는 소프트웨어로 구현되어 간단하고 빠른 오류 검출 기법이 필요함

링크 계층은 네트워크 어댑터 안에 하드웨어로 구현되어 `순환 중복 검사(CRC)` 를 사용

<br/>

## 6.2.3 순환 중복 검사(CRC)

**오늘날 컴퓨터 네트워크에서 널리 사용되는 오류 검출 기술은 `순환 중복 검사(cyclic redundancy check, CRC) 코드` 를 사용**

CRC 코드는 전송되는 비트열에 있는 0과 1 값을 계수로 갖는 다항식처럼 비트열을 생각할 수 있고, 또한 비트열에 적용되는 연산을 다항식 연산으로 이해하는 것이 가능하기 때문에 `다항식 코드(polynomial code)`로도 알려짐

<br/>

### CRC 동작 과정

<p align="center"><img width="400" alt="CRC" src="https://user-images.githubusercontent.com/76640167/214039446-5b9287a6-90fc-4040-8db6-81958b4f42cc.png">

1. 먼저 송신자와 수신자는 G로 표기되는 생성자로 알려진 r+1 비트 패턴에 대해 합의, 이때 G의 최상위 비트는 1이어야 함
2. 송신자는 D에 r개의 추가 비트 R을 선택해서 D 뒤에 덧붙임
    - 일반 이진 연산에서 2^k을 곱하는 것은 비트 패턴을 k개의 위치만큼 왼쪽으로 이동하는 것과 같음 즉, 위 그림의 식을 통해 d+r 패턴을 만들 수 있음
    - 만들어진 d+r 비트 패턴은 모듈로 2 연산을 이용하면 G로 정확히 나누어짐
3. 수신자는 d+r개의 수신 비트를 G로 나누고 나머지가 0이 아니면 오류가 발생한 것

<br/>

모든 CRC 검사는 덧셈의 올림이나 뺄셈의 빌림이 없는 모듈로 2 연산을 사용

즉, **피연산자를 비트별로 XOR한 것과 같음**

ex)

```
1011 XOR 0101 = 1110
1001 XOR 1101 = 0100

1011 - 0101 = 1110
1001 - 1101 = 0100
```

<br/>

### R을 계산하는 과정

먼저 다음과 같은 식을 만족하는 n이 있도록 하는 R을 구하고

```
D * 2^r XOR R = nG
```

<br/>

즉, `D * 2^r XOR R`을 나머지 없이 G로 나눌 수 있도록 R을 선택. 이 식의 양쪽에 R을 XOR(즉, 올림 없는 모듈로 2 덧셈)하면 다음과 같음

```
D * 2^r = nG XOR R
```

<br/>

이 식은 `D * 2^r` 을 G로 나누면 나머지가 정확히 R이 되는 것을 뜻함

다시 말해, 다음 처럼 R을 계산 가능

```
R = 나머지 D * 2^r / G
```

<br/>

ex)

<p align="center"><img width="300" alt="CRC e.g." src="https://user-images.githubusercontent.com/76640167/214039442-8d067a82-0303-49d3-9dd6-697e560578dc.png">

<br/>

국제 표준으로는 8비트, 12비트, 16비트, 32비트의 생성자 G가 정의되어 있음

각각의 CRC 표준은 r개 이하의 연속적인 비트 오류를 모두 검출할 수 있음
