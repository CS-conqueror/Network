# 7.2 무선 링크와 네트워크의 특징

<br/>

무선 링크는 유선 링크와 다르게 추가로 고려해야 하는 것들이 존재한다.

<br/>

### 신호 세기의 감소, 경로 손실

- 전자기파는 물체를 통과함에 따라 약화된다.
- 자유 공간에서도 전자기파 신호는 분산되고,  
  송신자와 수신자 사이의 거리가 증가함에 따라 신호의 세기가 감소한다.

이런 현상을 `경로 손실(path loss)`이라고도 한다.

<br/>

### 다른 출발지로부터의 간섭

- **동일 주파수 대역으로 전송되는** 무선 신호들은 서로 `간섭`하게 된다.
- 이러한 송신자 간의 간섭 외에 주변의 전자기 잡음(e.g., 근처의 모터 또는 전자레인지로 인한) 등도 간섭을 일으킬 수 있다.

이런 이유로 최근의 802.11 표준들은 5 GHz 대역에서 동작한다.

<br/>

### 다중 경로 전파

송신자와 수신자 간에 전송되는 전자기파의 일부가 물체나 지표에 부딪혀서  
서로 길이가 다른 여러 개의 경로를 겨처갈 때 `다중 경로 전파(multipath propagation) 현상`이 생긴다.

이는 수신 측에서 감지되는 신호를 또렷하지 않게 만든다.

<br/>

이들을 통해 알 수 있듯이, 유선 링크보다는 **무선 링크에서 비트 오류가 더 자주 발생한다.**

따라서 802.11을 포함한 무선 링크 프로토콜은 `강력한 CRC 오류 검출 코드`를 사용할 뿐만 아니라  
손상된 프레임을 재전송해주는 `링크 레벨의 신뢰성 있는 데이터 전송 프로토콜`을 사용한다.

<br/>

## SNR, BER

### SNR(signal-to-noise ratio)

> 측정된 수신 신호의 세기와 **잡음**의 상대적인 비율

- 단위 : 데시벨(dB)  
  (수신 신호의 진폭과 잡음의 진폭에 각각 밑이 10인 로그함수를 취한 비율의 20배)
- **SNR 값이 커질수록 수신 측에서는 잡음에도 불구하고 원하는 신호를 추출하기 쉬워진다.**

<br/>

### 비트 오류율, BER(bit error rate)

> 송신된 비트가 수신 측에서 오류로 검출될 확률

<br/>

아래 그림은 이상적인 무선 채널에서 세 가지 변조(modulation) 기법의 비트 오류율을 나타내는 BER 값과 SNR 값의 관계를 보여준다.

<br/>

<p align="center"><img width="400" alt="비트 오류율, 데이터 전송률, SNR" src="https://user-images.githubusercontent.com/86337233/216113468-31a7a965-62c5-4e7f-85c2-b2847fe3286c.png">

<br/>

### 동일한 변조 기법 내에서는 SNR 값이 높을수록 BER 값이 낮아진다

이는 송신자가 **출력 세기를 높이면** SNR 값이 커지고,  
동시에 수신된 비트에서 오류가 발생할 확률은 낮아지기 때문이다.

그러나 출력 세기를 어느 임계점 이상으로 높이는 것은 이득이 없다.

<br/>

출력 세기를 높이는 것의 단점은 다음과 같다.

- 출력 세기를 높일수록 송신 장치에서 더 많은 에너지가 소모되며, 이는 배터리를 사용하는 이동 통신 사용자에게는 중요한 문제다.
- 출력 세기를 높이면 다른 송신자의 전송과 더 많은 간섭이 생길 수 있다.

<br/>

### 동일한 SNR 값에서는 높은 전송률을 갖는 변조 기법이 더 높은 BER 값을 갖는다

위 그림에서 **SNR 값이 10 dB일 때**를 보자.

- 1 Mbps 전송률의 `BPSK 변조 기법`의 BER 값 = 10^(-7) 이하
- 4 Mbps 전송률의 `QAM16 변조 기법`의 BER 값 = 10^(-1)

10^(-1)는 실제 사용하기에는 지나치게 높은 오류율이기 때문에, 이 환경에서는 `BPSK 변조 기법`이 더 선호된다.

<br/>

반대로, **SNR 값이 20 dB일 때**를 보자.

- 1 Mbps 전송률의 `BPSK 변조 기법`의 BER 값은 표시되지도 않을 정도로 낮다.
- 4 Mbps 전송률의 `QAM16 변조 기법`의 BER 값 = 10^(-7)

만약 10^(-7) 정도의 BER 값이 별문제가 없다면 이 환경에서는 높은 전송률을 갖는 `QAM16 변조 기법`이 더 선호된다.

<br/>

*이러한 고찰을 기반으로 다음에 기술한 마지막 특성이 도출된다.*

<br/>

### 변조 기술을 채널의 조건에 적합하도록 유연하게 적응시키기 위해 물리 계층 변조 기법의 동적인 선택이 사용될 수 있다

SNR 및 BER 값은 이동성의 결과 또는 환경의 변화로 인해 바뀔 수 있다.

따라서 802.11 와이파이 또는 4G/5G 네트워크 기반의 `셀룰러 데이터 전송 시스템`에서는  
주어진 채널 환경에서 적당한 BER를 만족하는 동시에 최고의 전송률을 제공하는 적응적인 변조 기법을 선택할 수 있도록 허용한다.

<br/>

## 숨은 터미널 문제(hidden terminal problem)

아래의 상황에서 A가 B로, C가 B로 데이터를 전송한다고 가정하자.

<br/>

<p align="center"><img width="350" alt="장애물로 인한 숨은 터미널 문제" src="https://user-images.githubusercontent.com/86337233/216113474-f5e1735e-1927-4332-ae9c-af83c6852540.png">

<br/>

이때 A와 C의 전송 신호가 실제로 목적지 B에서 간섭됨에도 불구하고  
산이나 건물 등의 환경적인 장애물로 인해 **A와 C는 서로 상대방의 전송을 인지하지 못하는** 일이 생긴다.

이를 `숨은 터미널 문제(hidden terminal problem)`한다.

<br/>

## 페이딩(fading) 현상

신호가 무선 매체를 통과함에 따라 신호 세기가 약해지는 현상을 말한다.

<br/>

<p align="center"><img width="350" alt="페이딩" src="https://user-images.githubusercontent.com/86337233/216113475-3c2664ad-be89-4944-b2df-aff0097ee2d0.png">

<br/>

위 그림에서 A와 C가 서로의 전송을 검출하기에는 충분하지 않은 세기의 신호를 수신하는 거리에 있으나,  
이들 신호가 중간에 있는 B에서는 간섭된다.

<br/>

## 7.2.1 CDMA

`코드 분할 다중 접속(code division multiple access, CDMA)`은 **채널 분할 접속 프로토콜**의 하나로서,  
무선 랜 및 셀룰러 기술에서 아주 많이 사용되고 있다.

채널 분할 접속 프로토콜
- 공유 매체를 통해 호스트들이 통신할 때, 여러 송신자에 의해 전송된 신호가 수신 측에서 간섭되지 않게 해주는 프로토콜


<br/>

CDMA 프로토콜에서는 송신자가 전송하는 각 비트를 확장해서  
애초의 데이터 비트열보다 훨씬 빠른 속도(`칩 속도(chipping rate)`)로 변화되도록 하는 신호(코드)를 곱하는 방식으로 인코딩한다.

<br/>

아래의 간단하고 이상적인 CDMA 인코딩/디코딩 시나리오를 보자.

<br/>

<p align="center"><img width="700" alt="CDMA" src="https://user-images.githubusercontent.com/86337233/216113479-2c195c37-f808-4879-b4ae-b63c5bb390b7.png">

<br/>

데이터 비트들이 **CDMA 인코더에 도착하는 속도에 의해** 시간의 단위가 정의된다고 가정하자.

즉, 전송되는 각각의 원래 데이터 비트는 한 `비트 슬롯` 시간이 필요하다.

<br/>

i번째 비트 슬롯의 데이터 비트값을 `di`라고 하자.

계산의 편의상, 1 값을 갖는 데이터 비트는 `1`로, 0 값을 갖는 데이터 비트는 `-1`로 표시한다.

<br/>

각 비트 슬롯은 M개의 미니슬롯들로 더 분할된다. (그림에서는 M = 8)

- 송신자가 사용하는 **CDMA 코드**는 일련의 연속된 M개의 값, `Cm(m = 1, … , M)`으로 구성된다.
- 각각의 Cm 값은 1 또는 - 1 값을 갖는다.

<br/>

### ✅ 간섭하는 송신자가 없는 단순한 환경에서의 CDMA 동작

CDMA의 동작을 구체적으로 알아보기 위해, i번째 데이터 비트인 `di`에 대해 살펴보자.

<br/>

<p align="center"><img width="700" alt="이얏홍" src="https://user-images.githubusercontent.com/86337233/216113482-da191ac7-725e-4a0e-a071-a3b3165f944f.png">


<p align="center"><img width="200" alt="Zi,m" src="https://user-images.githubusercontent.com/86337233/216113483-93d5937f-de7b-4c8e-831a-c6ae10cc0019.png">

<br/>

수신자는 `인코딩된 바이트열 Zi,m`을 수신해서 다음과 같이 합성함으로써 `원래의 데이터 비트 di`를 생성한다.

<p align="center"><img width="290" alt="di" src="https://user-images.githubusercontent.com/86337233/216113484-8b5a4381-3aac-46d9-94aa-09bfc23dcab9.png">

<br/>

위의 시나리오 그림에서 해당 식을 통해 원래 데이터 비트가 수신자에 의해 정확히 얻어지는 것을 확인할 수 있다.

<br/>

### ✅ 간섭하는 송신자가 존재하는 환경에서의 CDMA 동작

현실에서는 서로 간섭하는 다수의 송신자가 존재한다.

이 경우, CDMA 수신자는 다른 송신자들이 전송한 비트들과 섞여 있는 상황에서 내 송신자의 원래 데이터 비트를 어떻게 다시 생성할 수 있을까?

<br/>

> CDMA는 **동시에 전송되어 간섭하는 비트 신호들을 더할 수 있다**는 전제하에 동작한다.

e.g., 같은 미니슬롯에서 3명의 송신자가 1의 값을 전송하고 4번째 전송자가 -1의 값을 전송한다면,  
그 미니슬롯에서 모든 수신자가 수신하는 신호는 2(= 1+1+1-1)가 된다.

<br/>

다수의 송신자가 있는 경우에도 송신자 s는 아래 식을 사용해서 자신의 인코딩된 전송 비트열을 정확히 계산한다.  
*(위에서의 식과 동일)*

<p align="center"><img width="430" alt="Zs.i,m" src="https://user-images.githubusercontent.com/86337233/216113486-90065ed3-f86a-42f0-aba7-4d3b08e5f03f.png">

<p align="center"><img width="200" alt="Zs.i,m 계산식" src="https://user-images.githubusercontent.com/86337233/216113493-b9678a2f-0ee4-42f0-9277-543ed179a789.png">

<br/>

i번째 비트 슬롯의 m번째 미니슬롯은 그 미니슬롯 동안 모든 N개의 송신자가 전송한 비트들의 `합`이 된다.


<p align="center"><img width="210" alt="Z*.i,m" src="https://user-images.githubusercontent.com/86337233/216113499-cac446b2-9b58-473f-95bf-6bc349ad6c3f.png">

<br/>

만약 송신자의 코드가 조심스럽게 선택되었다면,  
수신자는 다수 송신자로부터의 혼합된 신호로부터 원하는 송신자가 전송한 데이터만을 아래 식과 같이 특정 송신자 코드를 사용해서 쉽게 추출해낼 수 있다.

<p align="center"><img width="280" alt="di 계산" src="https://user-images.githubusercontent.com/86337233/216113502-30a736f2-4bf8-4eb1-b73f-1a9392748ed6.png">

<br/>

아래는 **두 송신자**가 존재할 때, 수신자가 위쪽 송신자로부터의 원래 데이터 비트열을 구하는 과정을 나타낸다.

수신자는 아랫쪽 송신자의 간섭에도 불구하고 첫 번째 송신자의 데이터를 추출할 수 있다.

<br/>

<p align="center"><img width="700" alt="송신자가 둘" src="https://user-images.githubusercontent.com/86337233/216113501-c74197d4-ac30-4ca8-bc11-9249486e985b.png">

<br/>

> 💡 CDMA는 (시간이나 주파수가 아닌) <b>코드를 분할(partitioning)</b>해서 각 노드에게 적당한 코드를 할당하는 분할 프로토콜이다.

<br/>

위에서는 CDMA에 대한 필수적인 설명만 했지만, 실제로는 많은 어려운 문제들이 있다.

1. CDMA 수신자가 특정 송신자의 신호를 추출해낼 수 있도록 CDMA 코드를 조심스럽게 선택해야 한다.
2. 앞에서는 여러 송신자로부터의 신호 세기가 수신자 쪽에서 동일하다고 가정했으나, 실제 상황에서 이런 경우는 드물다.
