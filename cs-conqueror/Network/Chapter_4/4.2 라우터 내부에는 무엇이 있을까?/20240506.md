## 4.2 라우터 내부에는 무엇이 있을까?

<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212551546-16b6533b-58ec-421a-9863-e7d581e0cb41.png">

위 그림은 일반적인 라우터 구조를 나타낸다.

라우터의 네 가지 요소
- 입력 포트(input port)
    - `포트` : 물리적인 입출력 라우터 인터페이스
    - `입력 링크` : 입력 포트의 맨 왼쪽 박스와 출력 포트의 맨 오른쪽 박스, 물리 계층을 수행
    - 입력 포트는 링크이 반대편에 있는 링크 계층과 상호 운용하기 위해 필요한 링크 계층 기능 수행
    - **입력 포트에서 검색 기능을 수행**
        - 가장 오른쪽 박스에서 수행됨
        - 여기서 포워딩 테이블을 참조하여 도착된 패킷이 스위치 구조를 통해 라우터 출력 포트를 결정
    - 제어 패킷은 입력 포트에서 라우팅 프로세서로 전달
- 스위치 구조
    - 라우터의 입력 포트와 출력 포트를 연결
    - 라우터 내부에 포함되어 있음
- 출력 포트(output port)
    - 스위치 구조에서 수신한 패킷을 저장
    - 필요한 링크 계층 및 물리 계층 기능을 수행하여 출력 링크로 패킷을 전송
    - 링크가 양방향일 경우, 출력 포트는 일반적으로 동일한 링크의 입력 포트와 한 쌍을 이룸
- 라우팅 프로세서
    - 제어 평면 기능을 수행
    - 기존 라우터에서는 라우팅 프로토콜을 실행하고 라우팅 테이블과 연결된 링크 상태 정보를 유지 관리하며 라우터의 포워딩 테이블을 계산
    - SDN 라우터에서 라우팅 프로세서는 원격 컨트롤러와 통신하여 원격 컨트롤러에서 계산된 포워딩 테이블 엔트리를 수신
    - 라우터의 입력 포트에 이러한 엔트리를 설치
    - 라우팅 프로세서는 네트워크 관리 기능도 수행

그림 4.4와 같이 라우터의 입력 포트, 출력 포트, 스위치 구조는 거의 항상 하드웨어로 구현

데이터 평면이 나노초 단위로 작동하는 동안 라우터의 제어 기능(라우팅 프로토콜 실행, 원격 컨트롤러와 통신(SDN의 경우) 및 관리 기능 수행)은 밀리초 또는 2초 단위로 작동 이러한 **제어 평면(control plane)** 기능은 일반적으로 소프트웨어로 구현되며 라우팅 프로세서에서 실행

<br>

### 4.2.1 입력 포트 처리 및 목적기 기반 전송

<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212552679-134bbf97-c8fd-452c-a6dc-283454e8d745.png">

입력 포트의 라인 종단 기능과 링크 계층 처리는 라우터의 개별 입력 링크와 관련된 물리 계층 및 데이터 링크 계층을 구현
<br>

입력 포트에서 수행되는 검색은 라우터 동작의 핵심
- 라우터는 포워딩 테이블을 사용하여 도착 패킷이 스위치 구조를 통해 전달되는 출력 포트를 검색
- 포워딩 테이블은 라우팅 프로세서(다른 네트워크 라우터의 라우팅 프로세서와 상호작용하기 위해 라우팅 프로토콜 사용)에서 계산/갱신 되거나 원격 SDN 컨트롤러에서 수신
- 포워딩 테이블은 라우팅 프로세서에서 입력 라인 카드로 복사됨
- 각 라인 카드에서 이와 같은 섀도 복사본을 이용하면 패킷 단위로 중앙 집중식 라우팅 프로세서를 호출하지 않게 되어 병목 현상을 피할 수 있음

라우터는 패킷의 목적지 주소의 **프리픽스(prefix)** 를 테이블의 엔트리와 매치
- 다수의 매치가 있을 때 라우터는 최장 프리픽스 매치 규칙(longest prefix matching rule)을 사용

검색은 개념적으로 간단하지만, 기가바이트 전송률에서 이 검색은 나노초 단위로 수행되어야 함
- 즉, 하드웨어 검색 뿐만 아니라 대형 테이블을 통한 단순 선형 검색 이외의 기술이 필요
- 메모리 접속 시간에 특별한 주의를 기울어야 하므로 내장형 DRAM과 빠른 SRAM 메모리가 있는 설계가 필요

검색을 통해 패킷의 출력 포트가 결정되면 패킷을 스위치 구조로 보낼 수 있음
- 일부 설계에서는 다른 입력 포트로부터 패킷이 현재 구조를 사용하고 있다면 패킷이 스위칭 구조에 들어가는 것을 일시적으로 차단할 수 있음
- 차단된 패킷은 입력 포트에 대기한 다음 나중에 구조를 교체하도록 예약
- '검색' 이외에 취해야할 조치
    - 물리 및 링크 계층 처리
    - 패킷의 버전 번호, 체크섬, TTL, 필드를 확인하고 이후 두 필드를 다시 사용
    - 네트워크 관리에 사용되는 카운터(수신된 IP 데이터그램 수) 갱신

목적지 IP 주소를 찾은(`매치`) 후에 패킷을 스위치 구조로 지정된 출력 포트로 전송(`액션`)하는 것은 라우터 뿐 아니라 많은 네트워크 장치에서 수행되는 일반적인 매치 플러스 액션

### 4.2.2 스위칭

스위치 구조는 패킷이 입력 포트에서 출력 포트로 실제로 스위칭(포워딩)되는 구조를 통과하기 때문에 라우터의 핵심임

<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212554598-53215480-9612-413e-8d8f-e628878e60d1.png">

**메모리를 통한 교환**
- 가장 단순한 초기의 라우터는 CPU(라우팅 프로세서)를 직접 제어해서 입력 포트와 출력 포트 사이에서 패킷을 스위칭하는 전통적인 컴퓨터
- 입력 포트와 출력 포트는 전통적인 운영체제에서 전통적인 I/O 장치처럼 작동
- 패킷이 도착하면 입력 포트는 라우팅 프로세서에게 인터럽트를 보내 패킷을 프로세서 메모리에 복사
- 이후 라우팅 프로세서는 헤더에서 목적지 주소를 추출하고 포워딩 테이블에서 적절한 출력 포트를 찾은 다음 패킷을 출력 포트의 버퍼에 복사
- 일부 최근 라우터는 메모리를 통해 스위칭하지만, 초기 라우터와의 주요 차이점은 목적지 주소를 검색하고 해당 메모리 위치에 패킷을 저장하는 것이 입력 라인 카드에서 처리함으로써 수행된다는 것

<br>

<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212554625-96f849a2-311f-4df7-a994-e4877392fd18.png">

**버스를 통한 교환**
- 입력 포트는 라우팅 프로세서의 개입 없이 공유 버스를 통해 직접 출력 포트로 패킷을 전송
- 일반적으로 미리 준비된 입력 포트 스위치 내부 레이블(헤더)이 로컬 출력 포트를 나타내는 패킷에게 전송되거나 버스에 패킷즐 전송하여 수행
- 모든 출력 포트에 패킷이 수신되지만 레이블과 매치되는 포트만 패킷을 유지
- 레이블은 스위치 내에서 버스를 통과하기 위해서만 사용되므로 출력 포트에서 제거
- 동시에 여러 패킷이 다른 입력 포트에 있는 라우터에 도착하면 한 번에 하나의 패킷만 버스를 통과할 수 있기 때문에 하나를 제외한 모든 패킷이 대기해야 함
- 모든 패킷이 하나의 버스를 건너가야 하므로 라우터의 교환 속도는 버스 속도에 의해 제한
- 작은 지역 및 기업 네트워크에서 작동하는 라우터에서 사용하기에 충분

<br>

<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212554641-56fbdfcb-c50d-4b60-8b2e-b61e85bf0e5f.png">   

**상호연결 네트워크를 통한 교환**

공유 버스의 대역폭 제한을 극복하는 방법은 이전의 멀티프로세서 컴퓨터 구조에서 프로세서를 상호연결하는 데 사용된 것과 같은 좀 더 복잡한 사호연결 네트워크를 사용하는 것
- 크로스바 스위치
    - N개의 입력 포트를 N개의 출력 포트에 연결하는 2N 버스로 구성된 상호연결 네트워크
    - 각 수직 버스는 교차점에서 각 수평 버스와 교차하며 스위치 구조 컨트롤러(로직은 스위칭 구조 자체의 일부)에 의해 언제든지 열거나 닫을 수 있음
    - 이전의 두 가지 스위칭 방식과는 달리 크로스바 스위치는 여러 패킷을 병렬로 전달 할 수 있음
    - 그러나 2개의 다른 입력 퐅에서 나오는 2개의 패킷이 동일한 출력 포트로 보내지는 경우 한 번에 하나의 패킷만 특정 버스에서 전송될 수 있기 때문에 입력을 기다려야 함
<br>

좀 더 정교한 상호연결 네트워크는 다단계 스위치 구조를 통해 각기 다른 입력 포트의 패킷이 동일한 출력 포트를 향해 동시에 전달할 수 있도록 여러 단계의 스위칭 요소를 사용

<br>

### 4.2.3 출력 포트 처리
<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212600107-7721ba99-bd00-4f26-b815-cc9bb0324f23.png"> 

출력 포트 처리는 출력 포트의 메모리에 저장된 패킷을 가져와 출력 링크를 통해 전송
<br>
전송을 위한 패킷 선택(스케줄링) 및 큐 제거, 필요한 링크 계층 및 물리 계층 전송 기능을 수행하는 것을 포함

### 4.2.4 어디에서 큐잉이 일어날까?

패킷 큐는 입력 포트와 출력 포트 모드에서 형성될 수 있음
- 큐의 위치와 범위(입력 포트 큐 또는 출력 포트 큐)는 트래픽 로드, 스위치 구조의 상대 속도 및 라인 속도에 따라서 달라짐
- 이 큐가 더 커지면 라우터으 ㅣ메모리가 결국 소모될 수 있고, 도착하는 패킷을 저장할 수 있는 메모리가 없을 때 **패킷 손실**이 발생

#### 입력 큐잉

<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212602449-2614d598-c84d-4b78-a5ff-0214177ef831.png"> 

입력 큐 앞쪽에 있는 2개의 패킷이 동일한 오른쪽 상단의 출력 포트로 전송되는 예
- 스위치 구조가 왼쪽 상단 큐의 앞쪽에서 패킷을 전달한다고 가정
- 이 경우, 왼쪽 하단 큐에 짙은 색으로 처리된 두 번째 패킷이 대기해야 함
- 아래쪽 밝은 패킷은 이동하려는 출력 링크가 경쟁이 없는 상태이지만 바로 앞의 검정 패킷 때문에 기다려야 함
- 이 현상은 입력 대기 중인 스위치에서의 **HOL(head-of-the-line) 차단(블로킹)** 이라고 함
- 라인의 앞쪽에서 다른 패킷이 막고 있으므로 입력 큐에서 대기 중인 패킷은 사용할 출력 포트가 사용 중이지 않아도 스위치 구조를 통해 전송되기 위해 기다려야 함

#### 출력 큐잉
<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212603601-f01b85d9-bb51-4a28-a27c-8307944f57ef.png"> 

스위치의 출력 포트에서 큐잉이 발생할 수 있는지 여부
- 스위치 구조가 포트 라인 속도보다 N배 빠른 경우에도 패킷 큐잉이 출력 포트에서 발생 가능
- 즉, 대기 중인 패킷의 수가 출력 포트에서 사용 가능한 메모리를 다 소모할 만큼 충분히 많아질 수 있음

<br>
들어오는 패킷을 저장할 메모리가 충분하지 않을 때 도착한 패킷을 삭제하거나 이미 대기 중인 하나 이상의 패킷을 제거하여 새로 도착한 패킷을 저장하기 위한 공간 확보 필요

<br>

어떤 경우에는 버퍼가 가득 차기 전에 패킷을 삭제하여 송신자에게 혼잡 신호를 제공하는 것이 바람직할 수 있음
<br>
AQM 알고리즘으로 알려진 많은 '패킷 삭제'와 '패킷 마킹' 정책이 제안되거나 분석
- 가장 폭넓게 연구되고 구현된 AQM 알고리즘 중 하나는 RED
<br>
큐잉의 결과는 출력 포트의 **패킷 스케줄러** 가 전송 대기 중인 패킷 중 하나의 패킷을 선택해야 한다는 것

####  얼마나 많은 버퍼가 요구되는가?
포트에 얼마나 많은 버퍼링이 제공되어야 하는가
- 몇 년 동안의 규칙은 링크 용량이 C일 때, 버퍼링의 양(B)은 평균 왕복시간(RTT)와 같아야 한다는 것
- 최근의 이론과 실험에서는 많은 수의 독립적인 TCP 흐름(N)이 링크를 통과할 때 필요한 버퍼링은 `B = RTT * C / 루트N` 이라고 제안
- 일반적으로 거대한 백본 라우터 링크를 통과하는 많은 수의 TCP 흐름이 있는 코어 네트워크에서, N값은 커질 수 있으며 필요한 버퍼 크기의 감소가 두드러짐

<br>

버퍼링이 클수록 라우터가 패킷 도착 속도의 큰 변동을 흡수하여 라우터의 패킷 손실률을 감소 시킬 수 있기 때문에 버퍼링이 더 낫다고 생각하는 것보다 버퍼가 클수록 큐잉 지연이 길어진다고 생각하는 편이 나음

<br>

<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212605581-8462495b-98e5-4fe3-a101-380a9c2955aa.png"> 

**버퍼블로트(bufferbloat)**
- 지속적 버퍼링으로 인한 긴 지연에 대한 시나리오
- 패킷의 과도한 버퍼링으로 인해 생기는 패킷 교환 네트워크의 높은 대기 시간의 원인

### 4.2.5 패킷 스케줄링
<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212629160-ffa328ee-fe9d-424e-bbc5-4de9711f8ea2.png"> 
<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212629250-0ba3b79f-32d6-4cf4-b183-cb1f302fbce1.png"> 

FCFS 방식
- 흔히 FIFO로도 알려짐
- 링크가 현재 다른 패킷을 전송 중이면, 출력 링크 큐에 도착한 패킷은 전송을 기다림
- 도착한 패킷을 담을 버퍼 공간이 충분하지 않을 경우 도착 패킷의 공간을 확보하기 위해 큐의 패킷 폐기 정책은 패킷 손실 여부 또는 다른 패킷을 규에서 제거할 것인지 여부 결정
- 패킷이 출력되는 링크를 통해 완전히 전송되면 (서비스를 받은 경우) 큐에서 제거 됨
- 스케줄링 규칙
    - 출력 링크 큐에 도착한 순서와 동일한 순서로 출력 링크에서 전송할 패킷을 선택

<br>

<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212632896-9184e337-91f4-4277-9b70-31d4ab83794d.png"> 
<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212632989-2c0b97aa-6ff9-4a51-b81a-a5af83ff29ff.png"> 


우선순위 큐잉
- 출력 링크에 도착한 패킷은 우선순위 클래스로 분류
- 네트워크 오퍼레이터는 네트워크 관리 정보를 운반하는 패킷이 사용자 트래픽보다 우선순위를 수신하도록 큐를 구성할 수 있음
- 각 우선순위 클래스에 일반적으로 고유한 큐 존재
- 전송할 패킷을 선택할 때 우선순위 큐는 전송 대기 중인 패킷으로 차 있는 상태이고 가장 높은 우선순위 클래스에서 패킷을 전송
- 우선순위가 동일한 패킷들 중에서의 선택은 FIFO 방식으로 행해짐
- **비선점 우선순위 큐잉(non-preemptive priority queueing)** 에서는 패킷의 전송이 시작되면 중단되지 않음

<br>

<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212637669-4db8f860-ae58-42b6-b341-5d83b3e93afb.png"> 
<p align="center"><img width="500" alt="네트워크 계층도" src="https://user-images.githubusercontent.com/76640167/212637698-f2ae0e82-3448-4012-b0af-cbe113979350.png"> 

라운드 로빈과 WFQ
- 라운도 로빈 큐잉 규칙에서 패킷은 우선순위 큐잉과 같이 클래스로 분류
- 클래스 간에는 엄격한 서비스 우선순위가 존재하지 않으며 라운드 로빈 스케줄러가 클래스 간에 서비스를 번갈아서 제공
- **작업 보존 큐잉(work-conserving queueing)** 의 경우 전송을 위해 큐에서 기다리는 패킷이 있다면 링크는 유휴 상태가 되는 것을 허용하지 않음
- 작업 보존 라운드 로빈 규칙에서는 클래스에서 패킷을 찾지만 아무것도 찾지 못하면 시퀀수의 다음 클래스를 바로 검사
- 라운드 로빈 큐잉의 일반화된 형태는 **WFQ(Wieghted Fair Queueing)** 규칙임
- 도착한 패킷은 적절한 클래스별 대기 영역에서 분류되며 대기
- 클래스가 여러 개 있을 때, 순환 방식으로 동작
- 각 클래스마다 다른 양의 서비스 시간을 부여받는다은 점에서 라운드 로빈과 차이가 있음
- 각 클래스는 가중치를 할당 받아 서비스 시간을 보장 받음
